{
  Copyright (c) 2021 Brian Callahan <bcallah@openbsd.org>

  Permission to use, copy, modify, and distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
}

{
  pl0c -- PL/0 compiler written in PL/0.
}

const
  CHECK_LHS	= 0,
  CHECK_RHS	= 1,
  CHECK_CALL	= 2,

  TOK_IDENT	= 'I',
  TOK_NUMBER	= 'N',
  TOK_CONST	= 'C',
  TOK_VAR	= 'V',
  TOK_PROCEDURE	= 'P',
  TOK_CALL	= 'c',
  TOK_BEGIN	= 'B',
  TOK_END	= 'E',
  TOK_IF	= 'i',
  TOK_THEN	= 'T',
  TOK_ELSE	= 'e',
  TOK_WHILE	= 'W',
  TOK_DO	= 'D',
  TOK_ODD	= 'O',
  TOK_WRITEINT	= 'w',
  TOK_WRITECHAR	= 'H',
  TOK_WRITESTR	= 'S',
  TOK_READINT	= 'R',
  TOK_READCHAR	= 'h',
  TOK_INTO	= 'n',
  TOK_SIZE	= 's',
  TOK_EXIT	= 'X',
  TOK_AND	= '&',
  TOK_OR	= '|',
  TOK_NOT	= '~',
  TOK_FORWARD	= 'F',
  TOK_DOT	= '.',
  TOK_EQUAL	= '=',
  TOK_COMMA	= ',',
  TOK_SEMICOLON	= ';',
  TOK_ASSIGN	= ':',
  TOK_HASH	= '#',
  TOK_LTHAN	= '<',
  TOK_GTHAN	= '>',
  TOK_LTHANE	= '{',
  TOK_GTHANE	= '}',
  TOK_PLUS	= '+',
  TOK_MINUS	= '-',
  TOK_MULTIPLY	= '*',
  TOK_DIVIDE	= '/',
  TOK_MODULO	= '%',
  TOK_LPAREN	= '(',
  TOK_RPAREN	= ')',
  TOK_LBRACK	= '[',
  TOK_RBRACK	= ']',
  TOK_STRING	= '"'
;

var
  raw size 1048576, { 8 MB, can hole up to 1 MB source code files }
  loc, { Where we are in the input code }
  symtab size 1048576, { 8 MB, can hold up to 29960 symbols }
  symtype, { For addsymbol }
  errstr size 35, { error string }
  token size 256, { 255 characters + '\0' }
  type, { token type }
  str size 256, { For cmpstr }
  symtabcnt, { To keep track of number of symtab entries }
  ret, { Return code for procedures that need one }
  depth, { Track nested subroutines }
  proc, { Track when we're inside a subroutine }
  value, { For number processing }
  line { line number }
;

forward expression;

{ Misc. functions }

procedure error;
begin
  writeStr 'pl0c: error: ';
  writeInt line;
  writeStr ': ';
  writeStr errstr;
  writeChar '\n';
  exit 1
end;

procedure cmpstr;
  var i;
begin
  i := 0;
  ret := 0;

  while i < 256 do
  begin
    if token[i] # str[i] then
      ret := 1;

    i := i + 1
  end;
end;

procedure clrstr;
  var i;
begin
  i := 0;

  while i < 256 do
  begin
    str[i] := '\0';
    i := i + 1
  end;
end;

procedure readin;
  var ch, i;
begin
  i := 0;
  readChar into ch;
  while ch # -1 do
  begin
    raw[i] := ch;
    i := i + 1;
    if i = 1048577 then { File too big! }
    begin
      errstr[0] := 'f';
      errstr[1] := 'i';
      errstr[2] := 'l';
      errstr[3] := 'e';
      errstr[4] := ' ';
      errstr[5] := 't';
      errstr[6] := 'o';
      errstr[7] := 'o';
      errstr[8] := ' ';
      errstr[9] := 'b';
      errstr[10] := 'i';
      errstr[11] := 'g';
      call error;
    end;
    readChar into ch;
  end;
  loc := 0 { Put the location pointer at the beginning }
end;

{ Lexer }

procedure comment;
begin
  while raw[loc] # '}' do
  begin
    if raw[loc] = '\0' then
    begin
      errstr[0] := 'u';
      errstr[1] := 'n';
      errstr[2] := 't';
      errstr[3] := 'e';
      errstr[4] := 'r';
      errstr[5] := 'm';
      errstr[6] := 'i';
      errstr[7] := 'n';
      errstr[8] := 'a';
      errstr[9] := 't';
      errstr[10] := 'e';
      errstr[11] := 'd';
      errstr[12] := ' ';
      errstr[13] := 'c';
      errstr[14] := 'o';
      errstr[15] := 'm';
      errstr[16] := 'm';
      errstr[17] := 'e';
      errstr[18] := 'n';
      errstr[19] := 't';
      call error
    end
    else if raw[loc] = '\n' then
      line := line + 1;

    loc := loc + 1
  end;
end;

procedure ident;
  var i, loop;
begin
  i := 0;
  loop := 1;

  while loop # 0 do
  begin
    loop := 0;

    if raw[loc] >= 'A' then
    begin
      if raw[loc] <= 'Z' then
      begin
        loop := 1;
        token[i] := raw[loc];
        i := i + 1;
        if i = 256 then
        begin
          errstr[0] := 't';
          errstr[1] := 'o';
          errstr[2] := 'k';
          errstr[3] := 'e';
          errstr[4] := 'n';
          errstr[5] := ' ';
          errstr[6] := 't';
          errstr[7] := 'o';
          errstr[8] := 'o';
          errstr[9] := ' ';
          errstr[10] := 'l';
          errstr[11] := 'o';
          errstr[12] := 'n';
          errstr[13] := 'g';
          call error
        end;
      end;
    end;

    if loop = 0 then
    begin
      if raw[loc] >= 'a' then
      begin
        if raw[loc] <= 'z' then
        begin
          loop := 1;
          token[i] := raw[loc];
          i := i + 1;
          if i = 256 then
          begin
            errstr[0] := 't';
            errstr[1] := 'o';
            errstr[2] := 'k';
            errstr[3] := 'e';
            errstr[4] := 'n';
            errstr[5] := ' ';
            errstr[6] := 't';
            errstr[7] := 'o';
            errstr[8] := 'o';
            errstr[9] := ' ';
            errstr[10] := 'l';
            errstr[11] := 'o';
            errstr[12] := 'n';
            errstr[13] := 'g';
            call error
          end;
        end;
      end;
    end;

    if loop = 0 then
    begin
      if raw[loc] >= '0' then
      begin
        if raw[loc] <= '9' then
        begin
          loop := 1;
          token[i] := raw[loc];
          i := i + 1;
          if i = 256 then
          begin
            errstr[0] := 't';
            errstr[1] := 'o';
            errstr[2] := 'k';
            errstr[3] := 'e';
            errstr[4] := 'n';
            errstr[5] := ' ';
            errstr[6] := 't';
            errstr[7] := 'o';
            errstr[8] := 'o';
            errstr[9] := ' ';
            errstr[10] := 'l';
            errstr[11] := 'o';
            errstr[12] := 'n';
            errstr[13] := 'g';
            call error
          end;
        end;
      end;
    end;

    if loop = 0 then
    begin
      if raw[loc] = '_' then
      begin
        loop := 1;
        token[i] := raw[loc];
        i := i + 1;
        if i = 256 then
        begin
          errstr[0] := 't';
          errstr[1] := 'o';
          errstr[2] := 'k';
          errstr[3] := 'e';
          errstr[4] := 'n';
          errstr[5] := ' ';
          errstr[6] := 't';
          errstr[7] := 'o';
          errstr[8] := 'o';
          errstr[9] := ' ';
          errstr[10] := 'l';
          errstr[11] := 'o';
          errstr[12] := 'n';
          errstr[13] := 'g';
          call error
        end;
      end;
    end;

    if loop # 0 then
      loc := loc + 1;
  end;

  loc := loc - 1;

  call clrstr;
  str[0] := 'c';
  str[1] := 'o';
  str[2] := 'n';
  str[3] := 's';
  str[4] := 't';
  call cmpstr;
  if ret = 0 then
    type := TOK_CONST;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'v';
    str[1] := 'a';
    str[2] := 'r';
    call cmpstr;
    if ret = 0 then
      type := TOK_VAR;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'p';
    str[1] := 'r';
    str[2] := 'o';
    str[3] := 'c';
    str[4] := 'e';
    str[5] := 'd';
    str[6] := 'u';
    str[7] := 'r';
    str[8] := 'e';
    call cmpstr;
    if ret = 0 then
      type := TOK_PROCEDURE;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'c';
    str[1] := 'a';
    str[2] := 'l';
    str[3] := 'l';
    call cmpstr;
    if ret = 0 then
      type := TOK_CALL;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'b';
    str[1] := 'e';
    str[2] := 'g';
    str[3] := 'i';
    str[4] := 'n';
    call cmpstr;
    if ret = 0 then
      type := TOK_BEGIN;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'e';
    str[1] := 'n';
    str[2] := 'd';
    call cmpstr;
    if ret = 0 then
      type := TOK_END;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'i';
    str[1] := 'f';
    call cmpstr;
    if ret = 0 then
      type := TOK_IF;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 't';
    str[1] := 'h';
    str[2] := 'e';
    str[3] := 'n';
    call cmpstr;
    if ret = 0 then
      type := TOK_THEN;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'e';
    str[1] := 'l';
    str[2] := 's';
    str[3] := 'e';
    call cmpstr;
    if ret = 0 then
      type := TOK_ELSE;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'w';
    str[1] := 'h';
    str[2] := 'i';
    str[3] := 'l';
    str[4] := 'e';
    call cmpstr;
    if ret = 0 then
      type := TOK_WHILE;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'd';
    str[1] := 'o';
    call cmpstr;
    if ret = 0 then
      type := TOK_DO;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'o';
    str[1] := 'd';
    str[2] := 'd';
    call cmpstr;
    if ret = 0 then
      type := TOK_ODD;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'w';
    str[1] := 'r';
    str[2] := 'i';
    str[3] := 't';
    str[4] := 'e';
    str[5] := 'I';
    str[6] := 'n';
    str[7] := 't';
    call cmpstr;
    if ret = 0 then
      type := TOK_WRITEINT;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'w';
    str[1] := 'r';
    str[2] := 'i';
    str[3] := 't';
    str[4] := 'e';
    str[5] := 'C';
    str[6] := 'h';
    str[7] := 'a';
    str[8] := 'r';
    call cmpstr;
    if ret = 0 then
      type := TOK_WRITECHAR;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'w';
    str[1] := 'r';
    str[2] := 'i';
    str[3] := 't';
    str[4] := 'e';
    str[5] := 'S';
    str[6] := 't';
    str[7] := 'r';
    call cmpstr;
    if ret = 0 then
      type := TOK_WRITESTR;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'r';
    str[1] := 'e';
    str[2] := 'a';
    str[3] := 'd';
    str[4] := 'I';
    str[5] := 'n';
    str[6] := 't';
    call cmpstr;
    if ret = 0 then
      type := TOK_READINT;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'r';
    str[1] := 'e';
    str[2] := 'a';
    str[3] := 'd';
    str[4] := 'C';
    str[5] := 'h';
    str[6] := 'a';
    str[7] := 'r';
    call cmpstr;
    if ret = 0 then
      type := TOK_READCHAR;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'i';
    str[1] := 'n';
    str[2] := 't';
    str[3] := 'o';
    call cmpstr;
    if ret = 0 then
      type := TOK_INTO;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 's';
    str[1] := 'i';
    str[2] := 'z';
    str[3] := 'e';
    call cmpstr;
    if ret = 0 then
      type := TOK_SIZE;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'e';
    str[1] := 'x';
    str[2] := 'i';
    str[3] := 't';
    call cmpstr;
    if ret = 0 then
      type := TOK_EXIT;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'a';
    str[1] := 'n';
    str[2] := 'd';
    call cmpstr;
    if ret = 0 then
      type := TOK_AND;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'o';
    str[1] := 'r';
    call cmpstr;
    if ret = 0 then
      type := TOK_OR;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'n';
    str[1] := 'o';
    str[2] := 't';
    call cmpstr;
    if ret = 0 then
      type := TOK_NOT;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'm';
    str[1] := 'o';
    str[2] := 'd';
    call cmpstr;
    if ret = 0 then
      type := TOK_MODULO;
  end;

  if ret # 0 then
  begin
    call clrstr;
    str[0] := 'f';
    str[1] := 'o';
    str[2] := 'r';
    str[3] := 'w';
    str[4] := 'a';
    str[5] := 'r';
    str[6] := 'd';
    call cmpstr;
    if ret = 0 then
      type := TOK_FORWARD;
  end;

  if ret # 0 then
    type := TOK_IDENT;
end;

procedure number;
  var i, loop;
begin
  i := 0;
  loop := 1;
  value := 0;

  while loop # 0 do
  begin
    loop := 0;

    if raw[loc] >= '0' then
    begin
      if raw[loc] <= '9' then
      begin
        loop := 1;
        token[i] := raw[loc];
        i := i + 1;
        if i = 256 then
        begin
          errstr[0] := 't';
          errstr[1] := 'o';
          errstr[2] := 'k';
          errstr[3] := 'e';
          errstr[4] := 'n';
          errstr[5] := ' ';
          errstr[6] := 't';
          errstr[7] := 'o';
          errstr[8] := 'o';
          errstr[9] := ' ';
          errstr[10] := 'l';
          errstr[11] := 'o';
          errstr[12] := 'n';
          errstr[13] := 'g';
          call error
        end;

        { XXX: sanity checking }
        value := value * 10;
        value := value + (raw[loc] - '0')
      end;
    end;

    if loop = 0 then
    begin
      if raw[loc] = '_' then
        loop := 1;
    end;

    if loop # 0 then
      loc := loc + 1;
  end;

  loc := loc - 1;

  type := TOK_NUMBER;
end;

procedure string;
  var i, loop;
begin
  i := 1;
  loop := 1;

  type := TOK_STRING;

  loc := loc + 1;
  token[0] := '"';
  while loop # 0 do
  begin
    if raw[loc] = '''' then
    begin
      loc := loc + 1;
      if raw[loc] # '''' then
        loop := 0
      else
      begin
        { XXX: sanity check }
        token[i] := '\\';
        i := i + 1;
        token[i] := raw[loc];
        i := i + 1
      end;
    end
    else if raw[loc] = '\n' then
    begin
      errstr[0] := 'u';
      errstr[1] := 'n';
      errstr[2] := 't';
      errstr[3] := 'e';
      errstr[4] := 'r';
      errstr[5] := 'm';
      errstr[6] := 'i';
      errstr[7] := 'n';
      errstr[8] := 'a';
      errstr[9] := 't';
      errstr[10] := 'e';
      errstr[11] := 'd';
      errstr[12] := ' ';
      errstr[13] := 's';
      errstr[14] := 't';
      errstr[15] := 'r';
      errstr[16] := 'i';
      errstr[17] := 'n';
      errstr[18] := 'g';
      call error
    end
    else if raw[loc] = '\0' then
    begin
      errstr[0] := 'u';
      errstr[1] := 'n';
      errstr[2] := 't';
      errstr[3] := 'e';
      errstr[4] := 'r';
      errstr[5] := 'm';
      errstr[6] := 'i';
      errstr[7] := 'n';
      errstr[8] := 'a';
      errstr[9] := 't';
      errstr[10] := 'e';
      errstr[11] := 'd';
      errstr[12] := ' ';
      errstr[13] := 's';
      errstr[14] := 't';
      errstr[15] := 'r';
      errstr[16] := 'i';
      errstr[17] := 'n';
      errstr[18] := 'g';
      call error
    end
    else
    begin
      { XXX: sanity check }
      token[i] := raw[loc];
      i := i + 1
    end;

    if loop # 0 then
      loc := loc + 1;
  end;

  loc := loc - 1;

  token[i] := '"';

  if i = 2 then
  begin
    token[0] := '''';
    token[2] := '''';
    type := TOK_NUMBER
  end
  else if i = 3 then
  begin
    if token[1] = '\\' then
    begin
      token[0] := '''';
      token[3] := '''';
      type := TOK_NUMBER
    end;
  end;
end;

procedure lex;
  var i, whitespace, isident, isnumber;
begin
  isident := 0;
  isnumber := 0;
  i := 0;

  while i < 256 do
  begin
    token[i] := '\0';
    i := i + 1
  end;

  whitespace := 1;
  while whitespace = 1 do
  begin
    if raw[loc] = ' ' then
    begin
      whitespace := 1;
      loc := loc + 1;
    end
    else if raw[loc] = '\t' then
    begin
      whitespace := 1;
      loc := loc + 1;
    end
    else if raw[loc] = '\n' then
    begin
      whitespace := 1;
      loc := loc + 1;
      line := line + 1;
    end
    else
      whitespace := 0
  end;

  if raw[loc] >= 'A' then
  begin
    if raw[loc] <= 'Z' then
    begin
      isident := 1;
      call ident;
    end;
  end;

  if isident = 0 then
  begin
    if raw[loc] >= 'a' then
    begin
      if raw[loc] <= 'z' then
      begin
        isident := 1;
        call ident;
      end;
    end;
  end;

  if isident = 0 then
  begin
    if raw[loc] = '_' then
    begin
      isident := 1;
      call ident;
    end;
  end;

  if isident = 0 then
  begin
    if raw[loc] >= '0' then
    begin
      if raw[loc] <= '9' then
      begin
        isnumber := 1;
        call number;
      end;
    end;
  end;

  if isident = 0 then
  begin
    if isnumber = 0 then
    begin
      if raw[loc] = '{' then
      begin
        call comment;
        type := -1
      end
      else if raw[loc] = '.' then
        type := TOK_DOT
      else if raw[loc] = '=' then
        type := TOK_EQUAL
      else if raw[loc] = ',' then
        type := TOK_COMMA
      else if raw[loc] = ';' then
        type := TOK_SEMICOLON
      else if raw[loc] = '#' then
        type := TOK_HASH
      else if raw[loc] = '+' then
        type := TOK_PLUS
      else if raw[loc] = '-' then
        type := TOK_MINUS
      else if raw[loc] = '*' then
        type := TOK_MULTIPLY
      else if raw[loc] = '/' then
        type := TOK_DIVIDE
      else if raw[loc] = '%' then
        type := TOK_MODULO
      else if raw[loc] = '(' then
        type := TOK_LPAREN
      else if raw[loc] = ')' then
        type := TOK_RPAREN
      else if raw[loc] = '[' then
        type := TOK_LBRACK
      else if raw[loc] = ']' then
        type := TOK_RBRACK
      else if raw[loc] = '<' then
      begin
        loc := loc + 1;
        if raw[loc] = '=' then
          type := TOK_LTHANE
        else if raw[loc] = '>' then
          type := TOK_HASH
        else
        begin
          loc := loc - 1;
          type := TOK_LTHAN
        end;
      end
      else if raw[loc] = '>' then
      begin
        loc := loc + 1;
        if raw[loc] = '=' then
          type := TOK_GTHANE
        else
        begin
          loc := loc - 1;
          type := TOK_GTHAN
        end;
      end
      else if raw[loc] = ':' then
      begin
        loc := loc + 1;
        if raw[loc] # '=' then
        begin
          errstr[0] := 'u';
          errstr[1] := 'n';
          errstr[2] := 'k';
          errstr[3] := 'n';
          errstr[4] := 'o';
          errstr[5] := 'w';
          errstr[6] := 'n';
          errstr[7] := ' ';
          errstr[8] := 't';
          errstr[9] := 'o';
          errstr[10] := 'k';
          errstr[11] := 'e';
          errstr[12] := 'n';
          errstr[13] := ':';
          errstr[14] := ' ';
          errstr[15] := '''';
          errstr[16] := ':';
          errstr[17] := raw[loc];
          errstr[18] := '''';
          call error
        end;

        type := TOK_ASSIGN;
      end
      else if raw[loc] = '''' then
      begin
        call string;
      end
      else if raw[loc] = '\0' then
        type := 0
      else
      begin
        errstr[0] := 'u';
        errstr[1] := 'n';
        errstr[2] := 'k';
        errstr[3] := 'n';
        errstr[4] := 'o';
        errstr[5] := 'w';
        errstr[6] := 'n';
        errstr[7] := ' ';
        errstr[8] := 't';
        errstr[9] := 'o';
        errstr[10] := 'k';
        errstr[11] := 'e';
        errstr[12] := 'n';
        errstr[13] := ':';
        errstr[14] := ' ';
        errstr[15] := '''';
        errstr[16] := raw[loc];
        errstr[17] := '''';
        call error
      end;
    end;
  end;

  loc := loc + 1
end;

{ Code generator }

procedure cg_end;
begin
  writeStr '/* PL/0 compiler 1.0.0 */\n'
end;

{ Parser }

procedure next;
begin
  call lex;
  while type = -1 do
    call lex;
end;

procedure syntax;
begin
  errstr[0] := 's';
  errstr[1] := 'y';
  errstr[2] := 'n';
  errstr[3] := 't';
  errstr[4] := 'a';
  errstr[5] := 'x';
  errstr[6] := ' ';
  errstr[7] := 'e';
  errstr[8] := 'r';
  errstr[9] := 'r';
  errstr[10] := 'o';
  errstr[11] := 'r';
  call error
end;

procedure expect_begin;
begin
  if type # TOK_BEGIN then
    call syntax;

  call next;
end;

procedure expect_call;
begin
  if type # TOK_CALL then
    call syntax;

  call next;
end;

procedure expect_const;
begin
  if type # TOK_CONST then
    call syntax;

  call next;
end;

procedure expect_do;
begin
  if type # TOK_DO then
    call syntax;

  call next;
end;

procedure expect_else;
begin
  if type # TOK_ELSE then
    call syntax;

  call next;
end;

procedure expect_end;
begin
  if type # TOK_END then
    call syntax;

  call next;
end;

procedure expect_exit;
begin
  if type # TOK_EXIT then
    call syntax;

  call next;
end;

procedure expect_forward;
begin
  if type # TOK_FORWARD then
    call syntax;

  call next;
end;

procedure expect_ident;
begin
  if type # TOK_IDENT then
    call syntax;

  call next;
end;

procedure expect_if;
begin
  if type # TOK_IF then
    call syntax;

  call next;
end;

procedure expect_into;
begin
  if type # TOK_INTO then
    call syntax;

  call next;
end;

procedure expect_number;
begin
  if type # TOK_NUMBER then
    call syntax;

  call next;
end;

procedure expect_odd;
begin
  if type # TOK_ODD then
    call syntax;

  call next;
end;

procedure expect_procedure;
begin
  if type # TOK_PROCEDURE then
    call syntax;

  call next;
end;

procedure expect_readchar;
begin
  if type # TOK_READCHAR then
    call syntax;

  call next;
end;

procedure expect_readint;
begin
  if type # TOK_READINT then
    call syntax;

  call next;
end;

procedure expect_size;
begin
  if type # TOK_SIZE then
    call syntax;

  call next;
end;

procedure expect_string;
begin
  if type # TOK_STRING then
    call syntax;

  call next;
end;

procedure expect_then;
begin
  if type # TOK_THEN then
    call syntax;

  call next;
end;

procedure expect_var;
begin
  if type # TOK_VAR then
    call syntax;

  call next;
end;

procedure expect_while;
begin
  if type # TOK_WHILE then
    call syntax;

  call next;
end;

procedure expect_writechar;
begin
  if type # TOK_WRITECHAR then
    call syntax;

  call next;
end;

procedure expect_writeint;
begin
  if type # TOK_WRITEINT then
    call syntax;

  call next;
end;

procedure expect_writestr;
begin
  if type # TOK_WRITESTR then
    call syntax;

  call next;
end;

procedure assign;
begin
  if type # TOK_ASSIGN then
    call syntax;

  call next;
end;

procedure comma;
begin
  if type # TOK_COMMA then
    call syntax;

  call next;
end;

procedure dot;
begin
  if type # TOK_DOT then
    call syntax;

  call next;
end;

procedure equal;
begin
  if type # TOK_EQUAL then
    call syntax;

  call next;
end;

procedure lbrack;
begin
  if type # TOK_LBRACK then
    call syntax;

  call next;
end;

procedure lparen;
begin
  if type # TOK_LPAREN then
    call syntax;

  call next;
end;

procedure rbrack;
begin
  if type # TOK_RBRACK then
    call syntax;

  call next;
end;

procedure rparen;
begin
  if type # TOK_RPAREN then
    call syntax;

  call next;
end;

procedure semicolon;
begin
  if type # TOK_SEMICOLON then
    call syntax;

  call next;
end;

procedure addsymbol;
  var i, n;
begin
  i := symtabcnt * 35; { First fresh location in symbol table }
  n := 0;
  while n < 32 do
  begin
    symtab[i] := token[n];
    i := i + 1;
    n := n + 1
  end;
  symtab[i] := symtype;
  i := i + 1;
  symtab[i] := depth - 1;
  i := i + 1;
  symtab[i] := 0;
  symtabcnt := symtabcnt + 1;
  if symtabcnt = 29961 then
  begin
    errstr[0] := 's';
    errstr[1] := 'y';
    errstr[2] := 'm';
    errstr[3] := 'b';
    errstr[4] := 'o';
    errstr[5] := 'l';
    errstr[6] := ' ';
    errstr[7] := 't';
    errstr[8] := 'a';
    errstr[9] := 'b';
    errstr[10] := 'l';
    errstr[11] := 'e';
    errstr[12] := ' ';
    errstr[13] := 'e';
    errstr[14] := 'x';
    errstr[15] := 'h';
    errstr[16] := 'a';
    errstr[17] := 'u';
    errstr[18] := 's';
    errstr[19] := 't';
    errstr[20] := 'e';
    errstr[21] := 'd';
    call error
  end;
end;

procedure arraycheck;
begin
end;

procedure arraysize;
  var i;
begin
  i := 0;

  i := 35 * (symtabcnt - 1);
  if symtab[i + 32] # TOK_VAR then
  begin
    errstr[0] := 'a';
    errstr[1] := 'r';
    errstr[2] := 'r';
    errstr[3] := 'a';
    errstr[4] := 'y';
    errstr[5] := 's';
    errstr[6] := ' ';
    errstr[7] := 'm';
    errstr[8] := 'u';
    errstr[9] := 's';
    errstr[10] := 't';
    errstr[11] := ' ';
    errstr[12] := 'b';
    errstr[13] := 'e';
    errstr[14] := ' ';
    errstr[15] := 'd';
    errstr[16] := 'e';
    errstr[17] := 'c';
    errstr[18] := 'l';
    errstr[19] := 'a';
    errstr[20] := 'r';
    errstr[21] := 'e';
    errstr[22] := 'd';
    errstr[23] := ' ';
    errstr[24] := 'w';
    errstr[25] := 'i';
    errstr[26] := 't';
    errstr[27] := 'h';
    errstr[28] := ' ';
    errstr[29] := '"';
    errstr[30] := 'v';
    errstr[31] := 'a';
    errstr[32] := 'r';
    errstr[33] := '"';
    call error
  end;

  { XXX: sanity check }
  symtab[i + 34] := value;
  if value < 1 then
  begin
    errstr[0] := 'i';
    errstr[1] := 'n';
    errstr[2] := 'v';
    errstr[3] := 'a';
    errstr[4] := 'l';
    errstr[5] := 'i';
    errstr[6] := 'd';
    errstr[7] := ' ';
    errstr[8] := 'a';
    errstr[9] := 'r';
    errstr[10] := 'r';
    errstr[11] := 'a';
    errstr[12] := 'y';
    errstr[13] := ' ';
    errstr[14] := 's';
    errstr[15] := 'i';
    errstr[16] := 'z';
    errstr[17] := 'e';
    call error
  end;
end;

procedure initsymtab;
  var i;
begin
  symtab[0] := 'm';
  symtab[1] := 'a';
  symtab[2] := 'i';
  symtab[3] := 'n';
  i := 4;
  while i < 32 do
  begin
    symtab[i] := '\0';
    i := i + 1
  end;
  symtab[i] := TOK_PROCEDURE; { type }
  i := i + 1;
  symtab[i] := 0; { depth }
  i := i + 1;
  symtab[i] := 0; { size }
  symtabcnt := 1 { 1 item in the symbol table }
end;

procedure symcheck;
begin
end;

procedure destroysymbols;
  var i, n;
begin
  i := 35 * (symtabcnt - 1);
  while symtab[i + 32] # TOK_PROCEDURE do
  begin
    n := 0;
    while n < 35 do
    begin
      symtab[i] := '\0';
      i := i + 1;
      n := n + 1
    end;
    symtabcnt := symtabcnt - 1;
    i := 35 * (symtabcnt - 1)
  end;
end;

procedure factor;
begin
  if type = TOK_IDENT then
  begin
    symtype := CHECK_RHS;
    call symcheck;
    { call cg_symbol; }
    call expect_ident;
    if type = TOK_LBRACK then
    begin
      call arraycheck;
      { call cg_symbol; }
      call lbrack;
      call expression;
      if type = TOK_RBRACK then
      begin
        { call cg_symbol; }
      end;
      call rbrack;
    end;
  end
  else if type = TOK_NUMBER then
  begin
    { call cg_symbol; }
    call expect_number
  end
  else if type = TOK_LPAREN then
  begin
    { call cg_symbol; }
    call lparen;
    call expression;
    if type = TOK_RPAREN then
    begin
      { call cg_symbol; }
    end;
    call rparen;
  end;
end;

procedure term;
  var loop;
begin
  loop := 1;

  call factor;

  while loop # 0 do
  begin
    loop := 0;

    if type = TOK_MULTIPLY then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call factor;
    end
    else if type = TOK_DIVIDE then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call factor;
    end
    else if type = TOK_MODULO then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call factor;
    end
    else if type = TOK_AND then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call factor;
    end;
  end;
end;

procedure expression;
  var loop;
begin
  loop := 1;

  if type = TOK_PLUS then
  begin
    { call cg_symbol; }
    call next
  end
  else if type = TOK_MINUS then
  begin
    { call cg_symbol; }
    call next
  end;

  call term;

  while loop # 0 do
  begin
    loop := 0;

    if type = TOK_PLUS then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call term;
    end
    else if type = TOK_MINUS then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call term;
    end
    else if type = TOK_OR then
    begin
      loop := 1;
      { call cg_symbol; }
      call next;
      call term;
    end;
  end;
end;

procedure condition;
begin
  if type = TOK_ODD then
  begin
    { call cg_symbol; }
    call expect_odd;
    call expression;
    { call cg_odd }
  end
  else
  begin
    call expression;

    if type = TOK_EQUAL then
    begin
      { call cg_symbol; }
      call next
    end
    else if type = TOK_HASH then
    begin
      { call cg_symbol; }
      call next
    end
    else if type = TOK_LTHAN then
    begin
      { call cg_symbol; }
      call next
    end
    else if type = TOK_GTHAN then
    begin
      { call cg_symbol; }
      call next
    end
    else if type = TOK_LTHANE then
    begin
      { call cg_symbol; }
      call next
    end
    else if type = TOK_GTHANE then
    begin
      { call cg_symbol; }
      call next
    end
    else
    begin
      errstr[0] := 'i';
      errstr[1] := 'n';
      errstr[2] := 'v';
      errstr[3] := 'a';
      errstr[4] := 'l';
      errstr[5] := 'i';
      errstr[6] := 'd';
      errstr[7] := ' ';
      errstr[8] := 'c';
      errstr[9] := 'o';
      errstr[10] := 'n';
      errstr[11] := 'd';
      errstr[12] := 'i';
      errstr[13] := 't';
      errstr[14] := 'i';
      errstr[15] := 'o';
      errstr[16] := 'n';
      errstr[17] := 'a';
      errstr[18] := 'l';
      call error
    end;

    call expression;
  end;
end;

procedure statement;
begin
  if type = TOK_IDENT then
  begin
    symtype := CHECK_LHS;
    call symcheck;
    { call cg_symbol; }
    call expect_ident;
    if type = TOK_LBRACK then
    begin
      call arraycheck;
      { call cg_symbol; }
      call lbrack;
      call expression;
      if type = TOK_RBRACK then
      begin
        { call cg_symbol; }
      end;
      call rbrack;
    end;
    if type = TOK_ASSIGN then
    begin
      { call cg_symbol; }
    end;
    call assign;
    call expression;
  end
  else if type = TOK_CALL then
  begin
    call expect_call;
    if type = TOK_IDENT then
    begin
      symtype := TOK_CALL;
      call symcheck;
      { call cg_call }
    end;
    call expect_ident;
  end
  else if type = TOK_BEGIN then
  begin
    { call cg_symbol; }
    call expect_begin;
    call statement;
    while type = TOK_SEMICOLON do
    begin
      { call cg_semicolon; }
      call semicolon;
      call statement
    end;
    if type = TOK_END then
    begin
      { call cg_symbol; }
    end;
    call expect_end;
  end
  else if type = TOK_IF then
  begin
    { call cg_symbol; }
    call expect_if;
    call condition;
    if type = TOK_THEN then
    begin
      { call cg_symbol; }
    end;
    call expect_then;
    call statement;
    if type = TOK_ELSE then
    begin
      { call cg_symbol; }
      call expect_else;
      call statement
    end;
    { call cg_closeblock }
  end
  else if type = TOK_WHILE then
  begin
    { call cg_symbol; }
    call expect_while;
    call condition;
    if type = TOK_DO then
    begin
      { call cg_symbol; }
    end;
    call expect_do;
    call statement;
  end
  else if type = TOK_WRITEINT then
  begin
    call expect_writeint;
    { call cg_writeint; }
    call expression;
    { call cg_rparen; }
    { call cg_rparen; }
    { call cg_semicolon; }
  end
  else if type = TOK_WRITECHAR then
  begin
    call expect_writechar;
    { call cg_writecharl }
    call expression;
    { call cg_rparen; }
    { call cg_rparen; }
    { call cg_semicolon; }
  end
  else if type = TOK_WRITESTR then
  begin
    call expect_writestr;
    if type = TOK_IDENT then
    begin
      symtype := CHECK_LHS;
      call symcheck;
      { call cg_writestr; }
      call expect_ident
    end
    else if type = TOK_STRING then
    begin
      { call cg_writestr; }
      call expect_string
    end
    else
    begin
      errstr[0] := 'w';
      errstr[1] := 'r';
      errstr[2] := 'i';
      errstr[3] := 't';
      errstr[4] := 'e';
      errstr[5] := 'S';
      errstr[6] := 't';
      errstr[7] := 'r';
      errstr[8] := ' ';
      errstr[9] := 't';
      errstr[10] := 'a';
      errstr[11] := 'k';
      errstr[12] := 'e';
      errstr[13] := 's';
      errstr[14] := ' ';
      errstr[15] := 'a';
      errstr[16] := 'n';
      errstr[17] := ' ';
      errstr[18] := 'a';
      errstr[19] := 'r';
      errstr[20] := 'r';
      errstr[21] := 'a';
      errstr[22] := 'y';
      errstr[23] := ' ';
      errstr[24] := 'o';
      errstr[25] := 'r';
      errstr[26] := ' ';
      errstr[27] := 'a';
      errstr[28] := ' ';
      errstr[29] := 's';
      errstr[30] := 't';
      errstr[31] := 'r';
      errstr[32] := 'i';
      errstr[33] := 'n';
      errstr[34] := 'g';
      call error
    end;
  end
  else if type = TOK_READINT then
  begin
    call expect_readint;
    if type = TOK_INTO then
      call expect_into;
    if type = TOK_IDENT then
    begin
      symtype := CHECK_LHS;
      call symcheck;
      { call cg_readint }
    end;
    call expect_ident;
  end
  else if type = TOK_READCHAR then
  begin
    call expect_readchar;
    if type = TOK_INTO then
      call expect_into;
    if type = TOK_IDENT then
    begin
      symtype := CHECK_LHS;
      call symcheck;
      { call cg_readchar }
    end;
    call expect_ident;
  end
  else if type = TOK_EXIT then
  begin
    call expect_exit;
    { call cg_exit; }
    call expression;
    { call cg_rparen; }
    { call cg_semicolon }
  end;
end;

procedure block;
begin
  if depth > 1 then
  begin
    errstr[0] := 'n';
    errstr[1] := 'e';
    errstr[2] := 's';
    errstr[3] := 't';
    errstr[4] := 'i';
    errstr[5] := 'n';
    errstr[6] := 'g';
    errstr[7] := ' ';
    errstr[8] := 'd';
    errstr[9] := 'e';
    errstr[10] := 'p';
    errstr[11] := 't';
    errstr[12] := 'h';
    errstr[13] := ' ';
    errstr[14] := 'e';
    errstr[15] := 'x';
    errstr[16] := 'c';
    errstr[17] := 'e';
    errstr[18] := 'e';
    errstr[19] := 'd';
    errstr[20] := 'e';
    errstr[21] := 'd';
    call error
  end;

  depth := depth + 1;

  if type = TOK_CONST then
  begin
    call expect_const;
    if type = TOK_IDENT then
    begin
      symtype := TOK_CONST;
      call addsymbol;
      { call cg_const }
    end;
    call expect_ident;
    call equal;
    if type = TOK_NUMBER then
    begin
      { call cg_symbol; }
      { call cg_semicolon }
    end;
    call expect_number;
    while type = TOK_COMMA do
    begin
      call comma;
      if type = TOK_IDENT then
      begin
        symtype := TOK_CONST;
        call addsymbol;
        { call cg_const }
      end;
      call expect_ident;
      call equal;
      if type = TOK_NUMBER then
      begin
        { call cg_symbol; }
        { call cg_semicolon }
      end;
      call expect_number;
    end;
    call semicolon;
  end;

  if type = TOK_VAR then
  begin
    call expect_var;
    if type = TOK_IDENT then
    begin
      symtype := TOK_VAR;
      call addsymbol;
      { cg_var }
    end;
    call expect_ident;
    if type = TOK_SIZE then
    begin
      call expect_size;
      if type = TOK_NUMBER then
      begin
        call arraysize;
        { call cg_array; }
      end;
      call expect_number;
    end;
    { call cg_semicolon; }
    while type = TOK_COMMA do
    begin
      call comma;
      if type = TOK_IDENT then
      begin
        symtype := TOK_VAR;
        call addsymbol;
        { call cg_var }
      end;
      call expect_ident;
      if type = TOK_SIZE then
      begin
        call expect_size;
        if type = TOK_NUMBER then
        begin
          call arraysize;
          { call cg_array; }
          call expect_number
        end;
      end;
      { call cg_semicolon }
    end;
    call semicolon;
    { call cg_crlf }
  end;

  while type = TOK_FORWARD do
  begin
    call expect_forward;
    if type = TOK_IDENT then
    begin
      symtype := TOK_FORWARD;
      call addsymbol;
      { call cg_forward }
    end;
    call expect_ident;
    call semicolon;
  end;

  while type = TOK_PROCEDURE do
  begin
    proc := 1;

    call expect_procedure;
    if type = TOK_IDENT then
    begin
      symtype := TOK_PROCEDURE;
      call addsymbol;
      { call cg_procedure }
    end;
    call expect_ident;
    call semicolon;

    call block;

    call semicolon;

    proc := 0;

    call destroysymbols;
  end;

  if proc = 0 then
  begin
    { cg_procedure; }
  end;

  call statement;

  { call cg_epilogue; }

  depth := depth - 1;

  if depth < 0 then
  begin
    errstr[0] := 'n';
    errstr[1] := 'e';
    errstr[2] := 's';
    errstr[3] := 't';
    errstr[4] := 'i';
    errstr[5] := 'n';
    errstr[6] := 'g';
    errstr[7] := ' ';
    errstr[8] := 'd';
    errstr[9] := 'e';
    errstr[10] := 'p';
    errstr[11] := 't';
    errstr[12] := 'h';
    errstr[13] := ' ';
    errstr[14] := 'f';
    errstr[15] := 'e';
    errstr[16] := 'l';
    errstr[17] := 'l';
    errstr[18] := ' ';
    errstr[19] := 'b';
    errstr[20] := 'e';
    errstr[21] := 'l';
    errstr[22] := 'o';
    errstr[23] := 'w';
    errstr[24] := ' ';
    errstr[25] := '0';
    call error;
  end;
end;

procedure dumpsymtab;
  var i, n, p;
begin
  i := 0;

  while i < symtabcnt do
  begin
    n := i * 35;
    p := 0;
    while symtab[n] # '\0' do
    begin
      writeChar symtab[n];
      n := n + 1;
      p := p + 1
    end;
    while p < 32 do
    begin
      p := p + 1;
      n := n + 1
    end;
    writeChar ' ';
    writeInt symtab[n];
    n := n + 1;
    writeChar '|';
    writeInt symtab[n];
    n := n + 1;
    writeChar '|';
    writeInt symtab[n];
    writeChar '\n';
    i := i + 1
  end;
end;

procedure parse;
begin
  { call cg_init; }

  call next;
  call block;
  call dot;

  if type # 0 then
  begin
    errstr[0] := 'e';
    errstr[1] := 'x';
    errstr[2] := 't';
    errstr[3] := 'r';
    errstr[4] := 'a';
    errstr[5] := ' ';
    errstr[6] := 't';
    errstr[7] := 'o';
    errstr[8] := 'k';
    errstr[9] := 'e';
    errstr[10] := 'n';
    errstr[11] := 's';
    errstr[12] := ' ';
    errstr[13] := 'a';
    errstr[14] := 't';
    errstr[15] := ' ';
    errstr[16] := 'e';
    errstr[17] := 'n';
    errstr[18] := 'd';
    errstr[19] := ' ';
    errstr[20] := 'o';
    errstr[21] := 'f';
    errstr[22] := ' ';
    errstr[23] := 'f';
    errstr[24] := 'i';
    errstr[25] := 'l';
    errstr[26] := 'e';
    call error;
  end;

  call cg_end;

  call dumpsymtab
end;

{ Main }

begin
  line := 1; { Line counting starts at 1 }
  type := -1; { To force first run }

  call readin;
  call initsymtab;
  call parse
end.
